spring.application.name=demo
# ===================================================================
# CONFIGURAÇÕES GERAIS DA APLICAÇÃO
# =================================================================

# Porta padrão em que a aplicação irá rodar.
# Railway/Render fornecem a variável PORT automaticamente
server.port=${PORT:8080}

# ===================================================================
# CONFIGURAÇÃO SSL/HTTPS (PRODUÇÃO)
# ===================================================================
# Habilitar HTTPS (descomente em produção com certificado válido)
# server.ssl.enabled=${SERVER_SSL_ENABLED:false}

# Caminho para o arquivo do certificado SSL (keystore)
# server.ssl.key-store=${SERVER_SSL_KEY_STORE:classpath:keystore.p12}

# Senha do keystore
# server.ssl.key-store-password=${SERVER_SSL_KEY_STORE_PASSWORD}

# Tipo do keystore (PKCS12 ou JKS)
# server.ssl.key-store-type=${SERVER_SSL_KEY_STORE_TYPE:PKCS12}

# Alias do certificado
# server.ssl.key-alias=${SERVER_SSL_KEY_ALIAS:tomcat}

# Força redirect de HTTP para HTTPS (descomente em produção)
# server.tomcat.redirect-context-root=false


# ===================================================================
# CONFIGURAÇÃO DO BANCO DE DADOS (DATASOURCE)
# ===================================================================
# Suporta MariaDB (local) e PostgreSQL (produção Railway/Render)
# Railway/Render fornecem DATABASE_URL automaticamente
spring.datasource.url=${DATABASE_URL:jdbc:mariadb://localhost:3306/backend}
spring.datasource.username=${DB_USERNAME:root}
spring.datasource.password=${DB_PASSWORD:aluno}

# Driver: detecta automaticamente PostgreSQL ou MariaDB
# Railway usa PostgreSQL, então configuramos para suportar ambos
spring.datasource.driver-class-name=${DB_DRIVER:org.mariadb.jdbc.Driver}
spring.jpa.database-platform=${DB_DIALECT:org.hibernate.dialect.MariaDBDialect}


# ===================================================================
# CONFIGURAÇÃO DA JPA E HIBERNATE
# ===================================================================
# Estratégia de geração do schema. 'update' é ideal para o ambiente de desenvolvimento.
spring.jpa.hibernate.ddl-auto=update

# Dialeto específico para o MariaDB. (Opcional em versões mais novas, mas bom para garantir).
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MariaDBDialect


# ===================================================================
# CONFIGURAÇÃO DE SEGURANÇA
# ===================================================================
# Chave secreta JWT - DEVE ser alterada em produção!
# Gerar com: openssl rand -base64 32
# Usar variável de ambiente: JWT_SECRET
jwt.secret=${JWT_SECRET:404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970}

# Tempo de expiração do token JWT (em milissegundos)
# 86400000 ms = 24 horas
jwt.expiration=${JWT_EXPIRATION:86400000}

# Tempo de expiração do refresh token (em milissegundos)
# 604800000 ms = 7 dias
jwt.refresh-token.expiration=${JWT_REFRESH_EXPIRATION:604800000}

# Chave de criptografia AES-256 para dados sensíveis (cartões)
# DEVE ser alterada em produção!
# Gerar com: openssl rand -base64 32
encryption.key=${ENCRYPTION_KEY:404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970}

# ===================================================================
# CONFIGURAÇÕES DE DEBUG (MUITO ÚTEIS PARA DESENVOLVIMENTO)
# ===================================================================
# Mostra no console o SQL que o Hibernate está executando por baixo dos panos.
spring.jpa.show-sql=true

# Formata o SQL exibido acima para que fique mais legível.
spring.jpa.properties.hibernate.format_sql=true

# Adiciona comentários ao SQL gerado para indicar qual parte do código o gerou.
spring.jpa.properties.hibernate.use_sql_comments=true


# ===================================================================
# CONFIGURAÇÃO DE QR CODES DE RASTREAMENTO
# ===================================================================
# Diretório onde os arquivos físicos dos QR Codes serão salvos.
# Caminho relativo ao diretório raiz da aplicação.
qrcode.diretorio=qrcodes


# ===================================================================
# CONFIGURAÇÃO DE PAGAMENTO PIX
# ===================================================================
# Chave PIX da loja (pode ser CPF, CNPJ, e-mail, telefone ou chave aleatória)
# Usar variável de ambiente em produção!
pix.chave=${PIX_CHAVE:12345678000190}

# Nome do beneficiário (nome da loja)
pix.nomeBeneficiario=${PIX_NOME_BENEFICIARIO:Loja Virtual LTDA}

# Cidade da loja
pix.cidade=${PIX_CIDADE:Sao Paulo}

# Tempo de expiração do PIX em minutos (padrão: 15 minutos)
pix.minutos-expiracao=${PIX_EXPIRACAO_MINUTOS:15}